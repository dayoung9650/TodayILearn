# 스트림 소개

자바 애플리케이션에서 컬렉션을 만들고 처리한다.

SQL 에서는 질의를 어떻게 구현해야 할지 명시할 필요가 없으며 구현은 자동으로 제공됨

컬렉션으로도 이와 비슷한 기능을 만들 수 있을까.

많은 요소를 포함하는 커다란 컬렉션을 병렬 처리를 사용하면 빠르지만 복잡하고 어렵다.

시간을 절약하고 편리한 삶을 누랄 수 있도록 자바 스트림이 자바 8에 추가되었다.

## 스트림이란 ? 

* 자바 8 API에 새로 추가된 기능
* 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현)으로 컬렉션 데이터를 처리할 수 있음
* 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있음
* 루프와 if 조건문 등의 제어 블록 사용하여 동작을 구현할지 지저할 필요 없이 동작의 수행만을 지정할 수 있음
* 선언형 코드와 동작 파라미터화를 활용하면 변하는 요구사항에 쉽게 대응할 수 있음
* 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있음
* 여러 연산을 파이프라인으로 연결해도 여전히 가독성과 명확성이 유지됨

#### 고수준 빌딩 블록

* Filter , sorted, map, collect 등의 연산
* 내부적으로 단일 스레드 모델에 사용할 수 있지만 멀티코어 아케텍처를 최대한 활용할 수 있게 구현되어 있음
* **데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정할 필요가 없음**

### 자바 8의 스트림 API 특징

1. 선언형 : 간결, 가독성 굳
2. 조립할 수 있음 : 유연성 굳
3. 병렬화 : 성능 굳



### 스트림과 컬렉션 차이점

자바의 기존 컬렉션과 새로운 스트림 모두 **연속된** 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공

#### **데이터를 언제 계산하느냐**가 컬렉션과 스트림의 가장 큰 차이

* 컬렉션 : 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 구조
  * DVD 에 저장된 영화에 비유
    * 적극적 생성 : 모든 값을 계산할 때까지 기다림
* 스트림 : 이론적으로 **요청할 때만 요소를 계산**하는 고정된 자료구조,
  * 사용자가 요청하는 값만 스트림에서 추출함
  * 게으르게 만들어지는 컬렉션
  * 사용자가 데이터를 요청할 때만 값을 계산
  * 인터넷으로 스트리밍하는 영화
    * 게으른 생성 : 필요할 때만 값을 계산

#### **데이터 반복 처리 방법** 차이

* 컬렉션
  * 외부 반복 : 사용자가 직접 요소를 반복해야 함
* 스트림
  * 내부 반복 : 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장

#### 내부반복의 장점

1. 작업을 투명하게 병렬로 처리하거나 더 최적하된 다양한 순서로 처리할 수 있음
2. 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택함



### 스트림의 특징

스트림 == 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

1. 연속된 요소
   1. 컬렉션은 자료구조이므로 컬렉션에서는 시간과 공간의 복잡성과 관련된 요서 저장 및 접근 연산이 주를 이룸
   2. 스트림은 filter, sorted, map 처럼 표현 계산식이 주를 이룸
   3. 컬렉션의 주제는 데이터이고 스트림의 주제는 계산
2. 소스
   1. 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비함
   2. 정렬된 컬렉션이면 정렬된 스트림 , 리스트 스트림이면 같은 리스트 (순서 유지) 
3. 데이터 처리 연산
   1. 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산 지원
   2. filter, map, reduce, find, matcj, sort 순차 혹은 병렬로 실행 가능



1. 파이프라이닝
   1. 게으름, 쇼트셔킷 같은 최적화 얻을 수 있음
   2. DB 질의와 비슷
2. 내부 반복
   1. 반복자를 이용해서 명시적으로 반복하는 컬렉션과 다리 내부 반복 지원

```java
import static java.util.stream.Collectors.toLsit;

List<String> threeHighCaloricDishNames = 
  menu.stream()
  		.filter(dish -> dish,getCalories() > 300)
  		.map(Dish::getName)
  		.limit(3)
  		.collect(toList())
  
System.out.println(threeHighCaloricDishNames); 
```

3. **딱 한 번만 탐색할 수 있음**
   1. 탐색된 스트림의 요소는 소비됨
   2. 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 함

### 

### 스트림 연산

```java
import static java.util.stream.Collectors.toLsit;

List<String> threeHighCaloricDishNames = 
  menu.stream() // 요리 리스트에서 스트림 얻기
  		.filter(dish -> dish,getCalories() > 300) //중간 연산
  		.map(Dish::getName) // 중간 연산
  		.limit(3) //중간 연산
  		.collect(toList()) // 스트림을 리스트로 변환
```



1. 중간 연산
   * filter, sorted 같은 중간연산은 다른 스트림을 반환함
   * **스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않음**
   * lazy !!! 
   * 중간 연산을 합친 다음에 합쳐지 중간 연산을 최종 연산으로 한 번에 처리하기 때문
   * 쇼트셔킷
   * 루프퓨전
2. 최종 연산
   * 스트림 파이프라이에서 결과를 도출
   * 최종 연산에 의해 List, Integer, void 등 스트림 연산 결과 반환 
   * count(), collect()



## 요약

1. 스트림은 소스에서 추출된 연속 요소로 데이터 처리 연산을 지원함
2. 스트림은 내부 반복 지원 내부 반복문은 filter, map, sorted 등의 연산으로 반복을 추상화함 
3. 중간연산, 최종연산
4. 중간연산은 스트림을 반환하며 다른 연산과 연결되는 연산, 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성할 수 없음
5. 스트림이 아닌 결과를 뱉는 연산이 최종연산
6. 스트림의 요소는 한번만 읽을 수 있으며 게으르다!!







